package streamx

var ServerTpl = `// Code generated by Kitex {{.Version}}. DO NOT EDIT.
package {{ToLower .ServiceName}}

import (
	{{- range $path, $aliases := .Imports}}
		{{- if not $aliases}}
			"{{$path}}"
		{{- else}}
			{{- range $alias, $is := $aliases}}
				{{$alias}} "{{$path}}"
			{{- end}}
		{{- end}}
	{{- end}}
)
{{- $protocol := .Protocol | getStreamxRef}}

type Server interface {
{{- range .AllMethods}}
{{- $unary := and (not .ServerStreaming) (not .ClientStreaming)}}
{{- $clientSide := and .ClientStreaming (not .ServerStreaming)}}
{{- $serverSide := and (not .ClientStreaming) .ServerStreaming}}
{{- $bidiSide := and .ClientStreaming .ServerStreaming}}
{{- $arg := index .Args 0}}
    {{.Name}}{{- if $unary}}(ctx context.Context, req {{$arg.Type}}) ({{.Resp.Type}}, error)
             {{- else if $clientSide}}(ctx context.Context, stream streamx.ClientStreamingServer[{{$protocol}}.Header, {{$protocol}}.Trailer, {{NotPtr $arg.Type}}, {{NotPtr .Resp.Type}}]) ({{.Resp.Type}}, error)
             {{- else if $serverSide}}(ctx context.Context, req {{$arg.Type}}, stream streamx.ServerStreamingServer[{{$protocol}}.Header, {{$protocol}}.Trailer, {{NotPtr .Resp.Type}}]) error
             {{- else if $bidiSide}}(ctx context.Context, stream streamx.BidiStreamingServer[{{$protocol}}.Header, {{$protocol}}.Trailer, {{NotPtr $arg.Type}}, {{NotPtr .Resp.Type}}]) error
             {{- end}}
{{- end}}
}

func RegisterService(svr server.Server, handler Server, opts ...server.RegisterOption) error {
    sp, err := {{$protocol}}.NewServerProvider(svcInfo)
    if err != nil {
        return err
    }
    nopts := []server.RegisterOption{
        streamxserver.WithProvider(sp),
    }
    nopts = append(nopts, opts...)
	return svr.RegisterService(svcInfo, handler, nopts...)
}
`
