/*
 * Copyright 2024 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package streamx

var ClientTpl = `// Code generated by Kitex {{.Version}}. DO NOT EDIT.

package {{ToLower .ServiceName}}

import (
	{{- range $path, $aliases := .Imports}}
		{{- if not $aliases}}
			"{{$path}}"
		{{- else}}
			{{- range $alias, $is := $aliases}}
				{{$alias}} "{{$path}}"
			{{- end}}
		{{- end}}
	{{- end}}
)
{{- $protocol := .Protocol | getStreamxRef}}

type Client interface {
{{- range .AllMethods}}
{{- $unary := and (not .ServerStreaming) (not .ClientStreaming)}}
{{- $clientSide := and .ClientStreaming (not .ServerStreaming)}}
{{- $serverSide := and (not .ClientStreaming) .ServerStreaming}}
{{- $bidiSide := and .ClientStreaming .ServerStreaming}}
{{- $arg := index .Args 0}}
    {{.Name}}{{- if $unary}}(ctx context.Context, req {{$arg.Type}}, callOptions ...streamxcallopt.CallOption) (r {{.Resp.Type}}, err error)
             {{- else if $clientSide}}(ctx context.Context, callOptions ...streamxcallopt.CallOption) (stream streamx.ClientStreamingClient[{{NotPtr $arg.Type}}, {{NotPtr .Resp.Type}}], err error)
             {{- else if $serverSide}}(ctx context.Context, req {{$arg.Type}}, callOptions ...streamxcallopt.CallOption) (stream streamx.ServerStreamingClient[{{NotPtr .Resp.Type}}], err error)
             {{- else if $bidiSide}}(ctx context.Context, callOptions ...streamxcallopt.CallOption) (stream streamx.BidiStreamingClient[{{NotPtr $arg.Type}}, {{NotPtr .Resp.Type}}], err error)
             {{- end}}
{{- end}}
}

func NewClient(destService string, opts ...streamxclient.Option) (Client, error) {
	var options []streamxclient.Option
	options = append(options, streamxclient.WithDestService(destService))
	options = append(options, opts...)
	cp, err := {{$protocol}}.NewClientProvider(svcInfo)
	if err != nil {
		return nil, err
	}
	options = append(options, streamxclient.WithProvider(cp))
	cli, err := streamxclient.NewClient(svcInfo, options...)
	if err != nil {
		return nil, err
	}
	kc := &kClient{streamer: cli, caller: cli.(client.Client)}
	return kc, nil
}

var _ Client = (*kClient)(nil)

type kClient struct {
    caller client.Client
    streamer streamxclient.Client
}

{{- range .AllMethods}}
{{- $unary := and (not .ServerStreaming) (not .ClientStreaming)}}
{{- $clientSide := and .ClientStreaming (not .ServerStreaming)}}
{{- $serverSide := and (not .ClientStreaming) .ServerStreaming}}
{{- $bidiSide := and .ClientStreaming .ServerStreaming}}
{{- $mode := ""}}
	{{- if $bidiSide -}} {{- $mode = "serviceinfo.StreamingBidirectional" }}
	{{- else if $serverSide -}} {{- $mode = "serviceinfo.StreamingServer" }}
	{{- else if $clientSide -}} {{- $mode = "serviceinfo.StreamingClient" }}
	{{- else if $unary -}} {{- $mode = "serviceinfo.StreamingUnary" }}
    {{- end}}
{{- $arg := index .Args 0}}
func (c *kClient) {{.Name}}{{- if $unary}}(ctx context.Context, req {{$arg.Type}}, callOptions ...streamxcallopt.CallOption) ({{.Resp.Type}}, error) {
    res := new({{NotPtr .Resp.Type}})
    _, err := streamxclient.InvokeStream[{{NotPtr $arg.Type}}, {{NotPtr .Resp.Type}}](
        ctx, c.streamer, {{$mode}}, "{{.RawName}}", req, res, callOptions...)
    if err != nil {
        return nil, err
    }
    return res, nil
{{- else if $clientSide}}(ctx context.Context, callOptions ...streamxcallopt.CallOption) (stream streamx.ClientStreamingClient[{{NotPtr $arg.Type}}, {{NotPtr .Resp.Type}}], err error) {
    return streamxclient.InvokeStream[{{NotPtr $arg.Type}}, {{NotPtr .Resp.Type}}](
        ctx, c.streamer, {{$mode}}, "{{.RawName}}", nil, nil, callOptions...)
{{- else if $serverSide}}(ctx context.Context, req {{$arg.Type}}, callOptions ...streamxcallopt.CallOption) (stream streamx.ServerStreamingClient[{{NotPtr .Resp.Type}}], err error) {
    return streamxclient.InvokeStream[{{NotPtr $arg.Type}}, {{NotPtr .Resp.Type}}](
        ctx, c.streamer, {{$mode}}, "{{.RawName}}", req, nil, callOptions...)
{{- else if $bidiSide}}(ctx context.Context, callOptions ...streamxcallopt.CallOption) (stream streamx.BidiStreamingClient[{{NotPtr $arg.Type}}, {{NotPtr .Resp.Type}}], err error) {
    return streamxclient.InvokeStream[{{NotPtr $arg.Type}}, {{NotPtr .Resp.Type}}](
        ctx, c.streamer, {{$mode}}, "{{.RawName}}", nil, nil, callOptions...)
{{- end}}
}
{{- end}}
`
